// Simple function for generically adding logging when object properties are interacted with via getters/setters,
// and is used for manipulating a given dictionary
let _defineProperty = function(that, name, map) {
    Object.defineProperty(that, name, {
        get: function() {
            util_log(that._name + "." + name + ".get() => (" + typeof map[name] + ") '"+ _truncateOutput(map[name]) + "'");
            return map[name];
        },
        set: function(v) {
            util_log(that._name + "." + name + " = '" + _truncateOutput(v) + "'");
            map[name] = v;
        }
    })
}
_defineProperty.toString = () => {
    return "_defineProperty"
}


// Slightly more complex function than _defineProperty for generically adding logging when object properties
// are interacted with via getters/setters, with the main difference being a private property name is
// created if not supplied, and the object "that" is being manipulated
let _defineSingleProperty = function(that, name, intvar) {
    /**
     * that -> is the object that this property will be defined to
     * name -> the name of the property to be set
     * intvar -> the private property name
    */
    if (typeof intvar === 'undefined') {
        intvar = "_" + name;
        that[intvar] = "";
    }

    Object.defineProperty(that, name, {
        get: function() {
            util_log(that._name + "." + name + ".get() => (" + typeof that[intvar] + ") '" + _truncateOutput(that[intvar]) + "'");
            return that[intvar];
        },
        set: function(v) {
            util_log(that._name + "." + name + " = (" + typeof v + ") '" + _truncateOutput(v) + "'");
            that[intvar] = v;
        }
    })
}
_defineSingleProperty.toString = () => {
    return "_defineSingleProperty"
}


var _truncateOutput = function(v, max_len) {
    // TODO: make max_len a command line parameter
    try {
        if (typeof max_len === 'undefined') {
            max_len = 250;
        }
        if (v === null)
            return "null";
        if (typeof v === 'undefined')
            return "undefined";
        var vtrunc = "" + v.toString();
        if (vtrunc.length > max_len) {
            vtrunc = vtrunc.substring(0, max_len) + " ... (truncated)";
        }
        return vtrunc.replace(/[^\x20-\x7E]/g, '?');
    } catch (err) {
        util_log("Exception occured in _truncateOutput: " + _inspect(err));
        throw err;
    }
}
_truncateOutput.toString = () => {
    return "_truncateOutput"
}


var _proxy_options = {
    "dont_fail": true,
    "verbose" : false
};


var _proxy = function(o, verbose = false, what = undefined) {
    ret = new Proxy(o, {
        get: function(target, name, receiver) {
            if (_proxy_options.verbose || verbose) {
                if (typeof name === 'symbol')
                    vname = name.toString();
                else
                    vname = name;
                if (what) {
                    var msg = what + "[" + vname + "]";
                } else {
                    var msg = "Proxy.get: " + _truncateOutput(target.toString(), 50) + "[" + vname + "]";
                }
            }
            if (name in target) {
                if (msg)
                    util_log(msg + " => " + Reflect.get(target, name));
                return Reflect.get(target, name, receiver);
            }
            // We should make this search case-insensitive
            // Use of Reflect object found here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect
            if (typeof name === 'string') {
                let lcname = name.toLowerCase();
                if (lcname in target) {
                    if (msg)
                        util_log(msg + " => " + Reflect.get(target, lcname, receiver));
                    return Reflect.get(target, lcname, receiver);
                }
                // If the lower case name is not in the target properties, look for keys in the Object
                for (const [key, value] of Object.entries(target)) {
                    if (key.toLowerCase() === lcname) {
                        if (msg)
                            util_log(msg + " => " + value);
                        return value;
                    }
                }
            }
            ret = Reflect.get(target, name);
            if (typeof name !== 'symbol') {
                vname = name.toString();
                if (typeof ret === 'undefined') {
                    if (_proxy_options.dont_fail) {
                        util_log(">>> FIXME: " + target._name + "[" + vname + "] not defined when getting");
                    }
                    else
                        throw new TypeError(">>> FIXME: " + target + "[" + vname + "] not defined when getting");
                } else {
                    util_log(">>> FIXME: " + target._name + "[" + vname + "] reflected to " + typeof ret);
                }
            }

            return ret;
        },
        set: function(target, name, value) {
            if (_proxy_options.verbose) {
                let vname;
                if (typeof name === 'symbol')
                    vname = name.toString();
                else
                    vname = name;
                util_log("Proxy.set: " + _truncateOutput(target.toString(), 50) + "[" + vname + "]");
            }
            if (name in target)
                return Reflect.set(target, name, value);
            if (typeof name === 'string') {
                let lcname;
                lcname = name.toLowerCase();
                if (lcname in target)
                    return Reflect.set(target, lcname, value);
                else {
                    if (target.toString() === "Window" && value.constructor.name === "Function") {
                        if (!isNaN(parseInt(name))) {
                            util_log("Unknown window instance property '" + name + "' set to function, let's try running it...");
                            value();
                        }
                    } else if (target._name) {
                        if (target.toString().startsWith("XMLHttpRequest")) {
                            null;
                        } else if (["window", "Collection", "Enumerator", ""].indexOf(target.toString()) === -1) {
                            util_log(">>> FIXME: " + target._name + "[" + name + "] not defined when setting");
                        }
                    }
                }
            }
            return Reflect.set(target, name, value);
        },
        construct: function(target, args, newTarget) {
            if (_proxy_options.verbose) {
                util_log("Proxy.construct: " + target + "(" + _truncateOutput(args.join(", "), 50) + ")");
            }
            return _proxy(Reflect.construct(target, args, newTarget));
        },
        apply: function(target, that, args) {
            if (_proxy_options.verbose) {
                util_log("Proxy.apply: " + target + "(" + _truncateOutput(args.join(", "), 50) + ")");
            }
            return Reflect.apply(target, that, args);
        }
    })
    return ret;
}
_proxy.toString = () => {
    return "_proxy"
}

if (typeof module !== 'undefined') {
    var exports = module.exports = {};
    exports._proxy = _proxy;
    exports._proxy_options = _proxy_options;
    exports._defineSingleProperty = _defineSingleProperty;
    var util_log = console.log;
}
