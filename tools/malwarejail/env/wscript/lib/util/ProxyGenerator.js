const util = require('node:util');
const METHODS_TO_NOT_LOG = ["writebyte"];
const METHODS_TO_NOT_TRUNCATE = ["exec", "shellexecute", "run"];

class ProxyGenerator {
    constructor(_class, _config) {
        const self = this;

        this._class = _class;
        this._config = _config || {
            logFunction: util_log
        };

        return class {
            constructor() {
                const args = [...arguments];
                self.initializedClass = new self._class(...args);
                let className = undefined;
                if (self.initializedClass.constructor === undefined) {
                    return null;
                } else {
                    className = self.initializedClass.constructor.name;
                }

                let constructedClass = new Proxy(self.initializedClass, self.getProxyProps());

                if ("_name" in constructedClass) {
                    className = constructedClass._name;
                }
                self.log('CONSTRUCT', className, null, [...args]);
                return constructedClass;
            }
        };
    }

    matchProperty(target, propKey) {
        const matched = {
            propKey: null,
            method: null
        }

        const methods = Object.getOwnPropertyNames(target.constructor.prototype);
        const props = Object.keys(target);

        let regex = null;
        try {
            regex = new RegExp(`^${propKey}$`, 'i');
        } catch (e) {
            return matched;
        }

        for (let i in props) {
            if (regex.test(props[i])) {
                matched.propKey = props[i];
            }
        }

        for (let i in methods) {
            if (regex.test(methods[i])) {
                matched.method = methods[i];
            }
        }

        return matched;
    }

    getProxyProps() {
        const self = this;

        return {
            get(target, propKey, receiver) {
                // Prepare for case-insensitivity
                const matched = self.matchProperty(target, propKey);

                // Accessing properties
                if (target.hasOwnProperty(matched.propKey)) {
                    self.log('GET', target._name, propKey, null, target[matched.propKey]);
                }
                // Calling functions
                else if (typeof target[matched.method] === 'function' && !self.isNative(target[matched.method])) {
                    return new Proxy(target[matched.method], {
                        apply(applyTarget, thisArg, args) {
                            // Log initial call before calling the method
                            self.log('CALL', thisArg._name, propKey, [...args]);
                            let result = Reflect.apply(applyTarget, thisArg, args);
                            // If a result exists, log that
                            if (result !== undefined && result !== null) {
                                self._config.logFunction(`> ${_truncateOutput(result)}`);
                            }
                            return result;
                        }
                    });
                }

                return target[matched.propKey];
            },
            set(target, propKey, value, receiver) {
                const matched = self.matchProperty(target, propKey);
                self.log('SET', target._name, propKey, [value]);
                target[matched.propKey] = value;
                return true;
            }
        }
    }

    isNative(value) {
        const toString = Object.prototype.toString;

        const fnToString = Function.prototype.toString;

        const reHostCtor = /^\[object .+?Constructor\]$/;

        const reNative = RegExp('^'
            + String(toString)
                .replace(/[.*+?^${}()|[\]\/\\]/g, '\\$&')
                .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?')
            + '$');

        // TODO: use isNative for native properties too
        // const type = typeof value;
        // return type === 'function' ? reNative.test(fnToString.call(value))
        // : (value && type === 'object' && reHostCtor.test(toString.call(value))) || false;

        return reNative.test(fnToString.call(value));

    }

    parseType(arg) {
        let res;

        switch (typeof arg) {
            case 'string':
                res = '"' + arg + '"';
                break;
            case 'number':
            case 'boolean':
            case 'function':
            case 'undefined':
                res = '' + arg;
                break;
            case 'object':
                if (arg === null) res = 'null';
                else if (arg.constructor.name === 'Array') res = '[' + arg.map(a => this.parseType(a)).join(', ') + ']';
                else if (arg.constructor.name === 'Object') {
                    let obj = [];
                    for (let val in arg) obj.push(`${val}: ${this.parseType(arg[val])}`);
                    res = `{${obj.join(', ')}}`;
                } else res = arg;
        }

        return res;
    }

    _truncateOutput(v, max_len) {
        // TODO: make max_len a command line parameter
        try {
            if (typeof max_len === 'undefined') {
                max_len = 250;
            }
            if (v === null)
                return "null";
            if (typeof v === 'undefined')
                return "undefined";

            if (v.toString) {
                var vtrunc = "" + v.toString();
            } else {
                console.log(v);
            }

            if (vtrunc.length > max_len) {
                vtrunc = vtrunc.substring(0, max_len) + " ... (truncated)";
            }
            return vtrunc.replace(/[^\x20-\x7E]/g, '?');
        } catch (err) {
            console.log("Exception occured in _truncateOutput: " + util.inspect(err));
            throw err;
        }
    }

    log(method, parentName, propertyName, args, result) {
        args = args ? args.map(arg => this.parseType(arg)).join(', ') : '';
        if (method === 'CALL' || method === 'CONSTRUCT') {
            if (propertyName && METHODS_TO_NOT_TRUNCATE.indexOf(propertyName.toLowerCase() === 0)) {
                args = `(${args})`;
            } else {
                args = `(${this._truncateOutput(args)})`;
            }
        }
        else if (method === 'SET') args = ` = ${this._truncateOutput(args)}`;

        if (method === 'CONSTRUCT') {
            this._config.logFunction(`new ${parentName}${args}`);
        } else {
            if (propertyName && METHODS_TO_NOT_LOG.indexOf(propertyName.toLowerCase()) === 0) {
                return;
            }
            // We don't want to log the access of private properties
            else if (propertyName.indexOf('_') !== 0) {
                if (result !== undefined && result !== null) this._config.logFunction(`${parentName}.${propertyName}${args} => ${this._truncateOutput(this.parseType(result))}`);
                else this._config.logFunction(`${parentName}.${propertyName}${args}`);
            }
        }
    }
}
