import util from 'node:util';
import 'log-timestamp';
import vm from 'node:vm';
import './cycle.cjs';
import minimist from "minimist";
import path from 'path';
import fs from "fs";
import { createHash } from 'node:crypto';
import { resolveObjectURL } from 'node:buffer';
import CryptoJS from "crypto-js";
import abort from 'node:process';

// WScript.js imports
import { Blob as BlobAlias } from "node:buffer";
import { URL as URLAlias } from "node:url";
import { Worker as WorkerAlias } from "node:worker_threads";
import { atob as AToBAlias, btoa as BToAAlias } from "abab";

// Basically, we are running CommonJS files in the vm.runincontext, so we cannot import
// specific modules from libraries. BUT we want to be able to rename libraries so that
// we can override their functionality. Therefore we need to import and rename libs in
// this file since it is being run as an ECMAScript, and then the renamed libs will be
// accessible in the context which is pass to vm.runincontext. We need to pass the
// "require" found below so that the CommonJS files have access to the "require" method.
import { createRequire } from "module";
const require = createRequire(import.meta.url);

process.on('uncaughtException', (err) => {
    console.log('!!! Uncaught Exception !!!');
    console.log(util.inspect(err));
});

console.log("mailware-jail, a malware sandbox ver. 0.20");
console.log("------------------------");

// commandline overwrites config.json values
var argv = minimist(process.argv.slice(2), {
    "boolean": true
});
var _exit = false;

if (argv.h || argv.help) {
    console.log("Usage: node jailme.js  [[-e file1] [-e file2] .. ] [-c ./config/config.json] \\");
    console.log("\t\t[-o ofile] [-b id] \\");
    console.log("\t\t[-s odir] [--down] [malware1 [malware2] .. ]");
    console.log("\t-c config .. use alternative config file, preceed with ./");
    console.log("\t-e ifile ... js that simulates specific environment");
    console.log("\t-o ofile ... name of the file where sandbox shall be dumped at the end");
    console.log("\t-s odir  ... output directory for generated files (malware payload)");
    console.log("\t-b id    ... browser type, use -b list for possible values");
    console.log("\t-t msecs ... number of miliseconds before terminating execution, default 1 minute");
    console.log("\t-f filename ... the value of the script full name property to be set");
    console.log("\t--stylesheet stylesheet  ... custom CSS stylesheet");
    console.log("\t--trace  ... print stack trace with every log line");
    console.log("\t--down   ... allow downloading malware payloads from remote servers");
    console.log("\t--h404   ... on download return always HTTP/404");
    console.log("\t--t404   ... on download return always HTTP/404 and throw exception");
    console.log("\t--extractfns   ... extract Function calls as files or 'payloads'");
    console.log("\t--extractevals   ... extract Eval calls as files or 'payloads'");
    console.log("\t--logerrors   ... log errors that are caught");
    console.log("\t--filealwaysexists   ... Scripting.FileSystemObject.FileExists() will return true");
    console.log("\tmalware  ... js with the malware code");
    console.log("If no arguments are specified the default values are taken from config.json");
    _exit = true;
}

var config_name = "./config/config.json";

if (typeof argv.c === 'string') {
    config_name = argv.c
}

var config = require(config_name);

if (typeof argv.b === 'string') {
    if (argv.b === 'list') {
        var a = require('./malware-jail/env/agents.js')._agents;
        console.log("Possible -b values:", Object.keys(a));
        _exit = true;
    } else {
        config.browser_type = argv.b
    }
}
if (_exit)
    process.exit();

console.log("Arguments: " + process.argv.slice(2).join(" "));

function parse_argv_array(a, b) {
    if (a) {
        if (Array.isArray(a) && a.length > 0)
            return a;
        else if (typeof a === 'string')
            return [a];
        else if (typeof a === 'boolean')
            return [];
    }
    return b;
}

// If a specific sandbox sequence has been requested and it has been named in the config.json file, then use that!
var sandbox_sequence_requested = argv.e;
if (typeof sandbox_sequence_requested === "string" && sandbox_sequence_requested in config) {
    config.sandbox_sequence = config[sandbox_sequence_requested];
    // Otherwise, assume that the sandbox sequence is a list of specific MalwareJail modules or was not specified at all and requires a default.
} else {
    config.sandbox_sequence = parse_argv_array(sandbox_sequence_requested, config.sandbox_sequence)
}

config.malware_files = parse_argv_array(argv._, config.malware_files);
console.log("Malware files: " + config.malware_files);

if (typeof argv.t === 'number')
    config.timeout = argv.t;
if (typeof config.timeout !== 'number')
    config.timeout = 1000 * 60;
console.log("Execution timeout set to: " + config.timeout / 1000 + " seconds");
if (argv.extractfns) {
    config.extractfns = true;
    console.log("Extract Function Calls to output directory");
}
if (argv.extractevals) {
    config.extractevals = true;
    console.log("Extract Eval Calls to output directory");
}
if (argv.logerrors) {
    config.logerrors = true;
    console.log("Log errors that are caught");
}
if (argv.filealwaysexists) {
    if (config.options !== undefined) {
        config.options["FileAlwaysExists"] = true
    } else {
        config.options = { "FileAlwaysExists": true };
    }
    console.log("Scripting.FileSystemObject.FileExists() will return true");
}
if (typeof argv.o === 'string')
    config.context_dump_after = argv.o
console.log("Output file for sandbox dump: " + config.context_dump_after);
if (typeof argv.s === 'string')
    config.save_files = argv.s
console.log("Output directory for generated files: " + config.save_files);

if (argv.stylesheet) {
    config.stylesheet = argv.stylesheet;
    console.log("Use a custom stylesheet: " + config.stylesheet);
}
//if (process.platform === "win32") {
//    var rl = require("readline").createInterface({
//        input: process.stdin,
//        output: process.stdout
//    });
//
//    rl.on("SIGINT", function() {
//        console.log("here");
//        process.emit("SIGINT");
//    });
//}
//
//process.on("SIGINT", function() {
//    //graceful shutdown
//    console.log("here");
//    process.exit();
//});

var sandbox = {};
sandbox._wscript_saved_files = {};
sandbox._wscript_urls = [];
sandbox._wscript_wmis = [];
sandbox._wscript_objects = [];
sandbox.toLowerCase = function () {
    return "sandbox";
}
sandbox.value = "sandbox";
sandbox.__dirname = path.resolve();

// too ambitious
// var sandbox = _proxy({});
if (argv.down)
    sandbox._download = "Yes";
else
    sandbox._download = "No";
if (argv.h404)
    sandbox._download = "Return HTTP/404";
if (argv.t404)
    sandbox._download = "Throw HTTP/404";
console.log("Download from remote server: " + sandbox._download);

var _show_stack;
if (argv.trace)
    _show_stack = true;
else
    _show_stack = false;

var _dont_log = false;

function mylog() {
    //if (arguments[0].startsWith("function"))
    //    debugger;
    if (_dont_log)
        return;
    console.log.apply(util, arguments);
    if (_show_stack) {
        var err = new Error();
        var st = err.stack;
        var st1 = st.split("\n");
        var st2 = st1.slice(2, st1.length - 5).join(", ");
        st2 = st2.replace(/\s+/g, ' ');
        console.log(" >" + st2)
    }
}

sandbox.toString = () => {
    return "sandbox";
}
sandbox._object_id = 1;
sandbox.util_log = mylog
sandbox._iconv = require("iconv-lite");

//require('http');
// FIXME: proxy?
//sandbox.Object = Object
//sandbox.Proxy = Proxy
//sandbox.Reflect = Reflect
//sandbox.unescape = unescape
sandbox.Buffer = Buffer
sandbox._options = (typeof config.options === 'undefined') ? {} : config.options;
sandbox._browser_type = config.browser_type;
sandbox._date = Date;
sandbox.require = require;
sandbox.fs = fs;
sandbox._setTimeout = setTimeout;
sandbox._clearTimeout = clearTimeout;
sandbox._setInterval = setInterval;
sandbox._clearInterval = clearInterval;
// https://github.com/mdevils/html-entities#decodetext-options
sandbox._decodeHTML = require("entities").decode;
sandbox._inspect = util.inspect;
sandbox._sync_request = require("sync-request");
sandbox._data = {}
sandbox._sc = ">>> Silencing catch ";
sandbox._browser_api = {
    'Array': Array,
    'Boolean': Boolean,
    'Date': Date,
    'Error': Error,
    'Math': Math,
    'Number': Number,
    'Object': Object,
    'RegExp': RegExp,
    'String': String,
    'Node': {},
    'Element': undefined,
    'HTMLElement': undefined,
    'JSON': JSON,
    'Function': Function
}

sandbox._stylesheet = config.stylesheet;
sandbox._save_files = config.save_files;

// These are required to support specific module aliasing
sandbox.BlobAlias = BlobAlias;
sandbox.URLAlias = URLAlias;
sandbox.WorkerAlias = WorkerAlias;
sandbox.AToBAlias = AToBAlias;
sandbox.BToAAlias = BToAAlias;

// We want these imports in the context
sandbox.resolveObjectURL = resolveObjectURL;
sandbox.CryptoJS = CryptoJS;
sandbox.abort = abort;

process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

let ctx = vm.createContext(sandbox);
let i;
// The file contents of the sample
let fc;

function run_in_ctx(files, log_catch = false) {
    var log_catch = log_catch;
    try {
        let comobjectsLoaded = false;
        for (i = 0; i < files.length; i++) {
            // We only need to log the first wscript object loaded, otherwise there are too many!
            if (files[i].indexOf("tools/malwarejail/env/wscript/") !== -1) {
                if (comobjectsLoaded) {
                    // No log
                    null;
                } else {
                    comobjectsLoaded = true;
                    let splitFilePath = files[i].split("/");
                    let wscriptIndex = splitFilePath.indexOf("wscript");
                    let fileName = splitFilePath.slice(wscriptIndex + 1).join("/");
                    let globName = files[i].replace(fileName, "");
                    console.log(" => Executing: " + globName + "*" + ((log_catch) ? ", reporting silent catches" : ""));
                    console.log("Preparing sandbox to emulate the Windows Scripting Host environment.")
                }
            }
            else {
                console.log(" => Executing: " + files[i] + ((log_catch) ? ", reporting silent catches" : ""));
            }
            fc = fs.readFileSync(files[i], 'utf8');
            sandbox._script_name = files[i];
            // log every exception caught by the script itself
            if (log_catch) {
                // Write two files, one with the unescaped file contents and another with the escaped file contents
                // Time for the unescaped file contents
                fc = fc.replace(/\bcatch\b\s*\((.*?)\)\s*{(?!\s*util_log\()/g, 'catch($1) { util_log(_sc + _inspect($1));');
                let fname = files[i].replace(/\//g, "_");
                let fname2 = "deobfuscated" + fname;
                let fpath2 = config.save_files + fname2;
                console.log("Saving: " + fname2);
                // Writing the file contents of the unescaped deobfuscated file to disk
                fs.writeFileSync(fpath2, fc);

                // Time for the escaped file contents
                // This appears to look for all unicode or bytes in the file content
                // Then it escapes characters such as \, ", '
                // Not required in our context for Assemblyline.
                // let r = /\\u([\d\w]{4})|\\x([\d\w]{2})/gi;
                // let x = fc.replace(r, function(match, p1, p2) {
                //     let grp = (p1) ? p1 : p2;
                //     let ret = String.fromCharCode(parseInt(grp, 16));
                //     switch (ret) {
                //         case '\\':
                //             ret = '\\\\';
                //             break;
                //         case '\'':
                //             ret = '\'\'';
                //             break;
                //         case '\"':
                //             ret = '\"\"';
                //             break;
                //     }
                //     return ret;
                // });
                // fname2 = config.save_files + "safestr_" + fname;
                // console.log("Saving: " + fname2);
                // fs.writeFileSync(fname2, x);
            }

            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#direct_and_indirect_eval
            // Avoid indirect calls with eval and use direct eval instead
            fc = fc.replace(/window(?:\.eval|\[(?:\"|\')eval(?:\"|\')\])\(/gi, "eval(");

            // This is use to end a declaration and remove extra whitespace.
            fc = fc.replace(/\} *var\b/g, "}; var");

            // We hate debugger calls
            if (!files[i].endsWith("WScript.js")) {
                fc = fc.replace(/\('debugger'\)\(\)|\bdebugger\b/g, "('')");
            }

            if ("WScript" in sandbox && argv.f) {
                sandbox.WScript.scriptfullname = argv.f;
            } else if ("Wscript" in sandbox) {
                sandbox.WScript.scriptfullname = files[i];
            }
            vm.runInContext(fc, ctx, {
                filename: files[i],
                timeout: config.timeout,
                breakOnSigint: true,
            });
            _dont_log = false;
        }
    } catch (err) {
        _dont_log = false;
        if ("_source" in err) {
            console.log("Execution finished: " + err._source);
            return true;
        }
        // We want to display the hash of the file in the exception, for consistency
        const hash = createHash("sha256");
        const input = fs.createReadStream(files[i]);
        input.on('readable', () => {
            const data = input.read();
            if (data)
                hash.update(data);
            else {
                const file_hash = hash.digest("hex");
                console.log("Exception occurred in " + file_hash + ": " + typeof err + " " + util.inspect(err));
                console.log("The hash " + file_hash + " corresponds to " + files[i]);
            }
        })

        return false;
    } finally {
        _dont_log = false;
    }
    return true;
}

console.log("==> Preparing Sandbox environment.");
if (!run_in_ctx(config.sandbox_sequence, false)) process.exit();

//process.on('SIGINT', function () {
//    console.log('Ctrl-C...');
//    process.exit(2);
//});

// clean up
sandbox.require = undefined;

// Run the malware
console.log("==> Executing malware file(s). =========================================");
process.exitCode = run_in_ctx(config.malware_files, config.logerrors) ? 0 : 1;
sandbox._config = config;
sandbox._arguments = process.argv.slice(2).join(" ");
let exiting = false;

var dump_sandbox = function () {
    var s2 = {};
    var ctx2 = vm.createContext(s2);
    var i, fc;
    s2.writeFile = fs.writeFileSync;
    s2.JSON = JSON;
    s2.sandbox = sandbox;
    s2.config = config;
    s2.util_log = console.log;
    s2.util_inspect = util.inspect;
    s2._escape = /\/|\\|%|:/gi;
    s2._f = {};
    function sha256(content) {
        return createHash('sha256').update(content).digest('hex')
    }
    s2.sha256 = sha256;
    let c = `
    var _f = function(t) {
        var out;
        out = JSON.stringify(JSON.decycle(sandbox), function(key, value) {
            // convert functions to string
            if (typeof value === 'function') {
                try {
                    return value.toString();
                } catch (err) {
                    util_log("Exception occured: " + typeof err + " ==> " + util_inspect(err));
                    util_log("Object details: " + typeof value + " ==> " + util_inspect(value));
                    return "!!! Exception occured !!!";
                }
            }
            return value;
        }, 4);

        writeFile(config.context_dump_after, out);
        util_log("The sandbox context has been saved to: " + config.context_dump_after);

        // This is determined to be excessively noise for some samples, so only extract if we need to
        if (config.extractevals) {
            p = sandbox._data["eval_calls"];
            var ec = 1;
            for (let key in p) {
                if (p.hasOwnProperty(key)) {
                    fname = "eval_" + ec++ + ".js";
                    fpath = config.save_files + fname;
                    util_log("Saving: " + fname);
                    writeFile(fpath, p[key]["report_catch"]);
                }
            }
        }

        // This is determined to be excessively noise for some samples, so only extract if we need to
        if (config.extractfns) {
            p = sandbox._Function_calls;
            for (let key in p) {
                if (p.hasOwnProperty(key)) {
                    fname = key + ".js";
                    fpath = config.save_files + fname;
                    util_log("Saving: " + fname);
                    writeFile(fpath, p[key][p[key].length - 1]);
                }
            }
        }

        var name, p, fname;
        p = sandbox._wscript_saved_files;

        // We want to look for unique saved files and only write the one to disk that doesn't have a generic name
        var saved_file_hashes = {};
        for (let key in p) {
            saved_file_hashes[key] = sha256(p[key]);
        }

        var all_sha256s = Object.values(saved_file_hashes);
        var all_file_names = Object.keys(saved_file_hashes);
        var keys_to_remove = new Set();
        // Go through each file name in the filename-hash object
        for (let key in saved_file_hashes) {
            var same_sha256s = [];
            var sha256_to_find = saved_file_hashes[key];
            // If the same hash is found more than once, we can remove one
            for (let index in all_sha256s) {
                sha256_value = all_sha256s[index]
                if (sha256_to_find == sha256_value) same_sha256s.push(all_file_names[index]);
            }
            // We have more than one of the same hash, therefore we need to figure out which file to keep
            if (same_sha256s.length > 1) {
                var keys_to_remove_per_hash = [];
                for (let file_name of same_sha256s) {
                    // If the file name is generic and there is a non-generic name
                    if (file_name.indexOf("Blob") >= 0 || file_name.indexOf("ObjectURL") >= 0) {
                        keys_to_remove_per_hash.push(file_name)
                    }
                }
                // If all names are generic, pop all except last
                if (keys_to_remove_per_hash.length == same_sha256s.length) {
                    for (let item of keys_to_remove_per_hash.slice(0, -1)) keys_to_remove.add(item)
                }
                // If at least one name is non-generic, pop all except that
                else if (keys_to_remove_per_hash.length < same_sha256s.length) {
                    for (let item of keys_to_remove_per_hash) keys_to_remove.add(item)
                }
            }
        }

        for (let key in p) {
            if (p.hasOwnProperty(key)) {
                if (keys_to_remove.has(key)) continue;
                fname = key.replace(_escape, "_");
                fpath = config.save_files + fname;
                util_log("Saving: " + fname);
                writeFile(fpath, p[key]);
            }
        }

        p = sandbox._wscript_urls;
        if (p !== undefined && p.length > 0) {
            out = JSON.stringify(p, null, 4);
            fname = "urls.json";
            fpath = config.save_files + fname;
            util_log("Saving: " + fname);
            writeFile(fpath, out);
        }
        p = sandbox._wscript_wmis;
        if (p !== undefined && p.length > 0) {
            out = JSON.stringify(p, null, 4);
            fname = "wmis.json";
            fpath = config.save_files + fname;
            util_log("Saving: " + fname);
            writeFile(fpath, out);
        }
    }

    _f();
    `

    vm.runInContext(c, ctx2, {
        timeout: 60 * 1000
    });
}

process.on('beforeExit', (code) => {
    if (exiting)
        return;
    exiting = true;
    console.log("==> Cleaning up sandbox.");
    sandbox._decodeHTML = undefined;
    sandbox._my_path = undefined;
    sandbox._browser_api = undefined;
    sandbox.util_log.toString = () => {
        return "util_log"
    }
    sandbox._iconv = undefined;
    sandbox._date = undefined;
    sandbox.require = undefined;
    sandbox._setTimeout = undefined;
    sandbox._clearTimeout = undefined;
    sandbox._setInterval = undefined;
    sandbox._clearInterval = undefined;
    sandbox._decodeHTML = undefined;
    sandbox._inspect = undefined;
    sandbox._pw32 = undefined;
    sandbox.Base64 = undefined;
    sandbox.console = undefined;

    console.log("==> Script execution finished, dumping sandbox environment to a file.");

    dump_sandbox(sandbox, fs.writeFileSync, config);

    return;
})
